# 数据结构：向量及其运算

### 向量的创建
向量可以通过`c()`函数进行创建，也可以通过`assign()`函数进行分配，如下

```
> a <- c(41, 56, 1, 32, 2, 8, 9, 12)
> print(a)
[1] 41 56  1 32  2  8  9 12
> assign('a', c(1, 2, 3, 4, 5, 6))
> print(a)
[1] 1 2 3 4 5 6
```

### 向量的运算
关于向量的运算，是逐元素进行的，如果有多个向量参与运算，那么长度较短的元素将会重复遍历，举个例子

```
> a <- c(41, 56, 1, 32, 2, 8, 9, 12)
> print(a)
[1] 41 56  1 32  2  8  9 12
> assign('a', c(1, 2, 3, 4, 5, 6))
> print(a)
[1] 1 2 3 4 5 6
> v <- a*a
> print(v)
[1]  1  4  9 16 25 36
> v <- a + a
> print(v)
[1]  2  4  6  8 10 12
> v <- a-a;
> print(v)
[1] 0 0 0 0 0 0
> a <- c(41, 56, 1, 32, 2, 8, 9, 12)
> t <- a > 30
> print(t)
[1]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE
```

### 生成常规序列
一种方法是通过`c(from:to)`函数生成，这种方式从from开始到to结束，步长为1,也可以是`c(to:from)`来生成，步长为1

```
> a <- c(1:5)
> print(a)
[1] 1 2 3 4 5
> a <- c(5:1)
> print(a)
[1] 5 4 3 2 1
```

另一种是通过`seq()`函数来生成，该函数原型如下
+ `seq(from, to)`：从from开始到to结束，步长为1，如果from大于to那么递减，否则递增
+ `seq(from, to, by = )`：从from开始到to结束，步长为by的参数
+ `seq(length = , from = , by = )`：从from的参数开始，以by的参数为步长，一直走length次
+ `rep(c(), times = )`：将向量c()整体循环times的参数次
+ `rep(c(), each = )`：将向量的每一个元素单个循环each参数次

```
> a = c(1:5)
> print(a)
[1] 1 2 3 4 5
> a = c(5:1)
> print(a)
[1] 5 4 3 2 1
> a <- seq(20, 10)
> print(a)
 [1] 20 19 18 17 16 15 14 13 12 11 10
> a <- seq(10, 20)
> print(a)
 [1] 10 11 12 13 14 15 16 17 18 19 20
> a <- seq(10, 20, by = 2)
> print(a)
[1] 10 12 14 16 18 20
> a <- seq(20, 10, by = 2)
Error in seq.default(20, 10, by = 2) : 'by'		// 注意这里，如果是递减但是步长为正数的话肯定会报错，因为相矛盾
> a <- seq(20, 10, by = -2)
> print(a)
[1] 20 18 16 14 12 10
> a <- seq(length = 10, from = 5, by = 0.2)
> print(a)
 [1] 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8
> a <- seq(length = 10, from = 5, by = -0.2)
> print(a)
 [1] 5.0 4.8 4.6 4.4 4.2 4.0 3.8 3.6 3.4 3.2
> a <- rep(a, times = 3)
> print(a)
 [1] 5.0 4.8 4.6 4.4 4.2 4.0 3.8 3.6 3.4 3.2 5.0 4.8 4.6 4.4 4.2 4.0 3.8 3.6 3.4

[20] 3.2 5.0 4.8 4.6 4.4 4.2 4.0 3.8 3.6 3.4 3.2
> a <- rep(a, each = 3)
> print(a)
 [1] 5.0 5.0 5.0 4.8 4.8 4.8 4.6 4.6 4.6 4.4 4.4 4.4 4.2 4.2 4.2 4.0 4.0 4.0 3.8

[20] 3.8 3.8 3.6 3.6 3.6 3.4 3.4 3.4 3.2 3.2 3.2 5.0 5.0 5.0 4.8 4.8 4.8 4.6 4.6

[39] 4.6 4.4 4.4 4.4 4.2 4.2 4.2 4.0 4.0 4.0 3.8 3.8 3.8 3.6 3.6 3.6 3.4 3.4 3.4

[58] 3.2 3.2 3.2 5.0 5.0 5.0 4.8 4.8 4.8 4.6 4.6 4.6 4.4 4.4 4.4 4.2 4.2 4.2 4.0

[77] 4.0 4.0 3.8 3.8 3.8 3.6 3.6 3.6 3.4 3.4 3.4 3.2 3.2 3.2
```

### 检查向量中的缺失值
可通过is.na(vector)来检查向量中的缺失值，该函数会返回一个新的向量，与原向量长度相同，若某个地方有缺失值那么为TRUE,否则为FALSE,我们先生成含有缺失值的向量，再通过is.na()方法来检查，如下

```
> z <- c(1:3,NA)
> print(z)
[1]  1  2  3 NA
> ind <- is.na(z)
> print(ind)
[1] FALSE FALSE FALSE  TRUE
> a <- c(1, 2, 3)
> length(a) <- 10
> ind <- is.na(a)
> print(ind)
 [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
```

### 字符向量及对字符向量的操作
字符向量就是向量的模式为字符，不用解释。

对字符向量的操作主要是通过paste函数完成的，该函数的原型如下

```
paste(..., sep = " ", collapse = NULL)
```

其中...代表若干个字符向量，如果超过两个那么就是对应元素相连形成一个新向量(元素较少的向量在连接完一轮之后再次从头开始)；加上seq参数，那么就是在...结果的基础之上再对每个向量拼接一下seq的参数会形成一个新的向量；再加上collapse参数之后，就是将之前的结果用collapse的参数分隔然后形成字符串，该字符串会作为向量的第一个元素，即结果还是向量。示例如下

```
>  paste(c('a', 'b', 'c'), seq(1, 10, by = 2))
[1] "a 1" "b 3" "c 5" "a 7" "b 9"
>  paste(c('a', 'b', 'c'), seq(1, 10, by = 2), seq = '_')
[1] "a 1 _" "b 3 _" "c 5 _" "a 7 _" "b 9 _"
>  paste(c('a', 'b', 'c'), seq(1, 10, by = 2), seq = '_', collapse = ",")
[1] "a 1 _,b 3 _,c 5 _,a 7 _,b 9 _"
```

### 选择和修改向量数据集的子集
选择我们一般是有条件的，比如剔除向量中的缺失值，如下

```
> x <- c(1, 2, 3, 4, 5)
> length(x) <- 10
> print(x)
 [1]  1  2  3  4  5 NA NA NA NA NA
> y <- x[!is.na(x)]
> print(y)
[1] 1 2 3 4 5
```

可以看出我们主要是通过is.na()函数来判断，其执行过程如下

首先,is.na()函数会根据向量是否含有缺失值将其转化为模式为logical的向量，即is.na(x)的最终结果是一个向量，即

```
> is.na(x)
 [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
```

注意，可以带print()也可以不带
然后x通过索引访问自身，只访问不是缺失值的元素，那么x怎么知道是否含有缺失值呢？答案是通过遍历is.na(x)的结果向量，如果结果向量当前位置的元素为FALSE，那么说明不是缺失值，再取反，即为TRUE时x就可以根据结果向量的索引取到值并赋值给y，如下

```
> !is.na(x)
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
```

然后依次访问自身并赋值给y即可。这就是`y <- x[!is.na(x)]`的流程

既然[]内的是一个布尔值，那么也就是说我们可以任意构造，只要是布尔值即可，那么我们还可以这样玩

```
> !is.na(x) & x > 3
 [1] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
```

既然[]左边的x代表向量自身，那么我们之前学过向量的运算，也可以像下面这样改变其元素

```
> x + 1
 [1]  2  3  4  5  6 NA NA NA NA NA
```

那么我们再综合一下，如下

```
> (x+1)[(!is.na(x)) & x>0]
[1] 2 3 4 5 6
```
解释为：先给x整体加1，然后再通过其对应的布尔向量取值。当然也可以赋值给一个向量R对象

而通过vector[from : to]的形式也可以截取向量的一部分，如下

```
> print(x)
 [1]  1  2  3  4  5 NA NA NA NA NA
> x[2 : 5]
[1] 2 3 4 5
```

还有更复杂的，仍然基于向量索引取值

```
> c("x","y")[rep(c(1,2,2,1), times=4)]
 [1] "x" "y" "y" "x" "x" "y" "y" "x" "x" "y" "y" "x" "x" "y" "y" "x"
```

解释为：

+ `c("x","y")`的结果是创建x和y两个字符构成的向量
+ `rep(c(1,2,2,1), times=4)`的结果是向量`1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1`
+ 然后遍历向量`1 2 2 1 1 2 2 1 1 2 2 1 1 2 2 1`以每个元素值为索引取向量`x y`的值

而通过vector[- (from : to)]就可以排除向量中从from到to的元素，如下

```
> x[- (1 : 5)]
[1] NA NA NA NA NA
> x[- (2 : 4)]
[1]  1  5 NA NA NA NA NA
```

在字符串向量中，我们可以通过names(vector)为vector自定义相对应的数值，然后仍然可以使用索引访问

```
> fruit <- c(5, 10, 1, 20)
> names(fruit) <- c("orange", "banana", "apple", "peach")
> lunch <- fruit[c("apple","orange")]
> print(fruit)
orange banana  apple  peach
     5     10      1     20
> print(lunch)
 apple orange
     1      5
```

### 常见数值型向量的运算函数
+-*/是必然可以使用的，是逐元素进行的。常用的函数如下
+ max(vector)：样本最大值
+ min(vector)：样本最小值
+ range(vector)：样本取值范围
+ length(vector)：样本长度
+ sum(vector)：样本元素之和
+ mean(vector)：样本均值
+ var(vector)：样本方差
+ log(vector)：以e为底数的对数函数
+ exp(vector)：自然对数e为底指数函数
+ sin(vector)：以向量各个元素为未知数的正弦函数
+ cos(vector)：以向量各个元素为未知数的余弦函数
+ tan(vector)：以向量各个元素为未知数的正切函数
+ sqrt(vector)：以向量各个元素为未知数的平方根

部分示例如下

```
> x <- c(1, 2, 3, 5, 9)
> range(x)
[1] 1 9
> prod(x)
[1] 270
> var(x)
[1] 10
> sort(x)
[1] 1 2 3 5 9
> log(x)
[1] 0.0000000 0.6931472 1.0986123 1.6094379 2.1972246
> exp(x)
[1]    2.718282    7.389056   20.085537  148.413159 8103.083928
> sin(x)
[1]  0.8414710  0.9092974  0.1411200 -0.9589243  0.4121185
> sqrt(x)
[1] 1.000000 1.414214 1.732051 2.236068 3.000000
```